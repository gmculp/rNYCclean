% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.seqsplt_addr.R
\name{parallel.seqsplt_addr}
\alias{parallel.seqsplt_addr}
\title{Split address strings in a large data frame into sequential combinations of words.}
\usage{
parallel.seqsplt_addr(in_clus, in_df, new_addr_col_name, id_col_name,
  addr_col_name, third_col_name, remove_orig = TRUE)
}
\arguments{
\item{in_clus}{the number of clusters available to the function as integer.  Required.}

\item{in_df}{a data frame containing addresses.  Required.}

\item{new_addr_col_name}{the name of output addresses column as string.  Required.}

\item{id_col_name}{the name of the unique identifier column as string.  Required.}

\item{addr_col_name}{the name of the input addresses column as string.  Required.}

\item{third_col_name}{the name of either the borough code or zip code column as string.  Required.}

\item{remove_orig}{option to exclude original address from output as binary.  Optional.}
}
\value{
A data frame containing \code{id_col_name}, \code{third_col_name}, and a column of address strings split into sequential combinations of words.
}
\description{
The \code{parallel.seqsplt_addr} function is a more efficient way to split address strings in a large data frame (+10,000 records) into sequential combinations of words using parallel processing.
}
\examples{
# create a data frame of addresses
ADDR <- c("ROOM 326 125 WORTH STREET","253 BROADWAY FLR 3",
    "C/O DOHMH 42-09 28 STREET")
BORO_CODE <- c(1,1,4)
u_id <- 1:length(ADDR)
df = data.frame(u_id, ADDR, BORO_CODE)

#split address column into sequential combinations 
df1 <- parallel.seqsplt_addr(in_clus = 1,in_df = df, 
    new_addr_col_name = "ADDR.seqsplt", id_col_name = "u_id", 
    addr_col_name = "ADDR", third_col_name = "BORO_CODE")

#preview records
head(df1)
}
